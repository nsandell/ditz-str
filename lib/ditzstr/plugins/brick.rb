require 'webrick'
require 'erb'
include WEBrick

module Ditz

class BrickView < HtmlView
	def initialize project, config, dir
		super.initialize project, config, dir
	end

	def link_to name, text
		links = generate_links
		return "<a href=\"#{links[name]}\">#{text}</a>"
	end

	def generate_new_issue options
    		past_rels, upcoming_rels = @project.releases.partition { |r| r.released? }
		erb = ERB.new IO.read(File.join(@template_dir, "new_issue.rhtml"))
		return erb.result binding()
	end

=begin
	def generate_release relname
		links = generate_links

		issue_link = "/new_issue.html?release=#{relname}"

		r = @project.release_for relname
		text = ErbHtml.new(@template_dir, links, :release => r,
				   :issues => @project.issues_for_release(r), :project => @project).
				   render_template("release")

		str_out=<<HERE
</table>

</div>
<div class="footer">Generated by <a href="http://ditz.rubyforge.org/">ditz</a>.</div>
HERE

		str_in=<<HERE
</table>
\n\n<h3><a href=\"#{issue_link}\">New Issue</a></h3>
</div>
<div class="footer">Generated by <a href="http://ditz.rubyforge.org/">ditz</a>.</div>
HERE

		return text.sub(str_out,str_in);
		#return text.sub("</table>","</table>\n\n<h3><a href=\"#{issue_link}\">New Issue</a></h3>")
	end

	def generate_component comp_name
		links = generate_links

		issue_link = "/new_issue.html?component=#{comp_name}"

		c = @project.component_for comp_name
		text = ErbHtml.new(@template_dir, links, :component => c,
				   :issues => @project.issues_for_component(c), :project => @project).
				   render_template("component")

		return text.sub("</table>","</table>\n\n<h3><a href=\"#{issue_link}\">New Issue</a></h3>")
	end

	def generate_issue issuename
		links = generate_links

		blah = @project.issues_for issuename

		case blah.size
		when 0; return "<html><body>No such issue found...</body></html>"
		when 1; 
			iss = blah.first
			return ErbHtml.new(@template_dir, links, :issue => iss,
				  :release => (iss.release ? @project.release_for(iss.release) : nil),
				  :component => @project.component_for(iss.component),
				  :project => @project).render_template("issue",{ :extra_summary_html => '', :extra_details_html => ''})
		else
			return "<html><body>Multiple issues found...</body></html>"
		end
	end
=end
end

class DitzServlet < HTTPServlet::AbstractServlet


	def initialize(server, options)
		super(server)
		@project = options[:project]
		@config = options[:config]
		@brickview = options[:brickview]
		@sharedir = options[:dir]
		@user = options[:user]
	end

	def do_GET(req,resp)
		puts "HOW IN THE FUCK"
		if req.path=="/index.html" or req.path=="/"
			#puts req.query['wee']
			resp['content-type'] = 'text/html'
			puts "How in the fuck?"
			resp.body = @brickview.generate_index 
		elsif req.path.start_with? '/release-'
			relname = req.path.sub('/release-','').sub('.html','')
			resp['content-type'] = 'text/html'
			resp.body = @brickview.generate_release relname
		elsif req.path.start_with? '/component-'
			compname = req.path.sub('/component-','').sub('.html','')
			resp['content-type'] = 'text/html'
			resp.body = @brickview.generate_component compname
		elsif req.path.start_with? '/issue-'
			issuename = req.path.sub('/issue-','').sub('.html','')
			resp['content-type'] = 'text/html'
			resp.body = @brickview.generate_issue issuename
		elsif req.path=='/new_issue.html'
			options = {}
			if req.query['component']!=nil
				options[:component] = req.query['component']
			end
			if req.query['release']!=nil
				options[:release] = req.query['release']
			end
			options[:creator] = @user
			resp['content-type'] = 'text/html'
			resp.body = @brickview.generate_new_issue options
		else
			HTTPServlet::FileHandler.new(@server,@sharedir).do_GET(req,resp)
		end
	end

	def do_POST(req,resp)
		resp['content-type'] = 'text/html'
		issue = Issue.create({:project => @project, :config=> @config},{:title => req.query['title'], :desc => req.query['description'], :type => req.query['type'], 
			      :component => req.query['component'], :release => req.query['release'], :reporter => 'poop', :comments => req.query['comments']});
		issue.log "created", @config.user, req.query['comments']
		resp.body = "<html><head><meta HTTP-EQUIV=\"REFRESH\" content=\"0; url=/component-#{req.query['component']}.html\"></head><body>Redirecting...</body></html>"
		@project.add_issue issue
		@project.assign_issue_names!
	end
end

class Operator

	def start_webrick(config = {})
       		config.update(:Port => 8080)
        	server = HTTPServer.new(config)
        	yield server if block_given?
        	['INT', 'TERM'].each {|signal| 
                	trap(signal) {server.shutdown}
        	}
        	server.start
	end


	operation :brick, "Start brick web server for issue management.", :maybe_dir
	def brick project, config, dir
		brickview = BrickView.new(project,config, dir)
		sharedir = File.dirname Ditz::find_ditz_file("index.rhtml")
		start_webrick { |server| 
			imgdir = File.dirname Ditz::find_ditz_file("index.rhtml")
        		server.mount('/', DitzServlet, {:brickview => brickview, :dir =>sharedir, :user=>config.user, :project=>project, :config=>config })
		}
	end
end

end
